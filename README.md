# pyracf

## PyRACF: A Python module for analyzing RACF security

PyRACF is a powerful Python module that simplifies the parsing and querying of any RACF database, providing an efficient and intuitive way to analyze security setups on IBM Z systems. By consuming the IRRDBU00 unload, PyRACF generates "Panda DataFrames" for each 'recordtype', which allow for seamless manipulation and analysis of the data.

Pandas is a powerful data manipulation library in Python that allows for easy querying of the DataFrames generated by PyRACF. With Pandas, you can perform complex queries on the security data to extract meaningful insights into the security posture of your system.

PyRACF's support for saving and loading pickle files makes it easier than ever to work with large RACF datasets, giving you the ability to perform comprehensive analyses of your security setup.

For more information on the various records, please refer to the [IBM documentation](https://www.ibm.com/docs/en/zos/3.1.0?topic=records-irrdbu00-record-types) on IRRDBU00 record types and the [record formats](https://www.ibm.com/docs/en/zos/3.1.0?topic=records-record-formats-produced-by-database-unload-utility) produced by the database unload utility. The DataFrames generated by PyRACF feature the same 'fieldnames' as outlined in the documentation, ensuring consistency and accuracy in your analyses.

To get started with PyRACF, install it using `pip install pyracf` or explore the source code on [GitHub](https://github.com/wizardofzos/pyracf/releases/latest). Use PyRACF to take control of your security data and protect your IBM Z systems from threats.


## Documentation

[Summary of changes](docs/ReleaseNotes.rst)

[Installation steps](docs/Installation.rst)

[Preview manual](docs/_build/markdown/index.md)

[Wiki](../../wiki)

[Concepts presentation, May 2024](docs/_external/GSE-NL-2024-concepts.pdf)

## Sample code
  
### Parsing IRRDBU00 unloads like a boss

    >>> from pyracf import RACF
    >>> mysys = RACF('/path/to/irrdbu00')
    >>> mysys.parse()
    >>> mysys.status
    {'status': 'Still parsing your unload', 'lines-read': 200392, 'lines-parsed': 197269, 'lines-per-second': 63934, 'parse-time': 'n.a.'}
    >>> mysys.status
    {'status': 'Ready', 'lines-read': 7137540, 'lines-parsed': 2248149, 'lines-per-second': 145048, 'parse-time': 49.207921}
    
### Using Pickle Files

    >>> from pyracf import RACF
    >>> mysys = RACF('/path/to/irrdbu00')
    >>> mysys.parse_fancycli(save_pickles='/tmp/pickles', prefix='mysys-')
    >>> hash(mysys.groups.values.tobytes())
    -8566685915584060910

Then later, you don't need to parse the same unload again, just do:

    >>> from pyracf import RACF
    >>> mysys = RACF(pickles='/tmp/pickles', prefix='mysys-')
    >>> hash(mysys.groups.values.tobytes())
    -8566685915584060910

### Example use-case

Get all users that have not logged in (on?) since January 1st 2022. And print userID and last logon...

    import time
    from pyracf import IRRDBU

    mysys = IRRDBU('/path/to/irrdbu00')
    mysys.parse()
    while mysys.status['status'] != 'Ready':
        time.sleep(5)
    selection = mysys.users.loc[mysys.users.USBD_LASTJOB_DATE<="2022-01-01"][['USBD_NAME','USBD_LASTJOB_DATE']]
    for user in selection.values:
      print(f"Userid {user[0]}, last active: {user[1]}")

Create a neat XLSX

    import time
    from pyracf import IRRDBU
    mysys = IRRDBU('/path/to/irrdbu00')
    mysys.parse()
    while mysys.status['status'] != 'Ready':
        time.sleep(5)
    mysys.xls('/path/to/my.xlsx')

Print z/OS UNIX profiles

    mysys.general('FACILITY', 'BPX.SUPERUSER')
    mysys.general('FACILITY', 'BPX.**')  # show only the FACILITY BPX.** profile
    mysys.general('FACILITY')  # show all FACILITY profiles

    mysys.generals.find('FAC*', 'BPX.**')  # show all BPX profiles
    mysys.generals.find('UNIXPRIV') # print all in UNIXPRIV

Show group information

    mysys.connect('SYS1')            # users connected to SYS1 groups
    mysys.connect('**','IBMUSER')    # groups IBMUSER is connected to

    mysys.connectData.find('SYS*','IBM*') # connects using patterns
    mysys.connectData.find(re.compile('SYS[AB].*','PROD.*'))   # regex with alternatives
    mysys.connectData.find(GRP_SPECIAL='YES', REVOKE=='YES')   # group special revoked
    mysys.connectData.find(GPMEM_AUTH=['CONNECT','JOIN'])      # users with connect authorities

    mysys.users.query("index in @mysys.connect('SYS1').index")  # user details of users connected to SYS1

Show access list information

    mysys.datasetPermit('SYS1.**')                       # IDs permitted on SYS1.**
    mysys.datasetPermit(id='IBMUSER', access='ALTER')    # where is IBMUSER permitted
    mysys.datasetPermit(id='*')                          # where is ID(*) permitted

    mysys.datasets.find('SYS1.**').acl(access='ALTER')    # IDs ALTER access on any SYS1 dataset profile
    mysys.datasets.find('SYS%.**').acl(allows='UPDATE')   # IDs with access that allows UPDATE
    mysys.datasets.find('SYS%.**').acl(allows='UPDATE', resolve=True)    # groups and user permits combined 
    mysys.datasets.find('PROD.**').acl(permits=False, admin=True)        # who can change groups or profiles to change access on PROD data sets
    mysys.generals.find('XFAC*', 'CKR.**').acl()                         # permits on zSecure Admin/Audit profile

    mysys.datasets.find(ALL_USER_ACCESS='UPDATE')         # UACC or ID(*) set to UPDATE

    mysys.datasets.match('SYS1.PARMLIB').acl()            # permits on profile for a specific data set

Show group tree information

    print(msys.grouptree)                   # group - superior group - subgroups in UNIX tree format
    msys.ownertree.format('simple')         # group - OWNER in simple format
    msys.grouptree                          # get the dict


# Contribute to PyRACF

If you've some additions and/or bugfixes, feel free to [fork](https://github.com/wizardofzos/pyracf/fork) this repository, make your additions and fire a pull request.




